<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构复习总结 | 第二期 | 线性表</title>
      <link href="/posts/d195e58.html"/>
      <url>/posts/d195e58.html</url>
      
        <content type="html"><![CDATA[<h2 id="【复习重点】"><a href="#【复习重点】" class="headerlink" title="【复习重点】"></a>【复习重点】</h2><p>线性表是<strong>算法题命题的重点</strong>，其实现要求具有一定的性能。算法最重要的是<strong>思想</strong>，尽力表达算法的思想和步骤。在明确线性表<strong>定义</strong>的基础上掌握线性表的<strong>逻辑结构</strong>和<strong>存储结构</strong>，然后再掌握各种<strong>基本操作</strong>（最核心、最基本的操作）。</p><p>在研究生入学考试中，线性表的考察主要有以下<strong>八大考点</strong>：<strong>特性对比问题、移动次数计算和静态链表、插入删除、归并、建表、逆置、划分和取最值</strong>。</p><h2 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h2><p>线性表是具有<strong>相同特性</strong>数据元素的<strong>有限序列</strong>。</p><ul><li>相同特性：将同一类事物归类，方便批量处理。</li><li>有限：表中元素个数为n，n有限大，n可以为0。</li><li>序列：表中元素排成一列，体现一对一的逻辑特性（每个元素有则仅有一个前驱和一个后继）。</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>线性表的顺序存储称作<strong>顺序表</strong>，用<strong>一组地址连续的存储单元依次存储</strong>线性表中的数据元素。我们常用数组来描述顺序表，一维的数组可以<strong>静态分配</strong>，也可以<strong>动态分配</strong>。</p><p>静态分配的代码演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> data[MaxSize];</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">SqList L;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>动态分配代码演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> *data;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">SqList L;</span><br><span class="line"><span class="comment">//C初始动态分配语句</span></span><br><span class="line">L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*InitSize);</span><br><span class="line"><span class="comment">//C++初始动态分配语句</span></span><br><span class="line">L.data = <span class="keyword">new</span> <span class="type">int</span>[InitSize];</span><br><span class="line"><span class="keyword">if</span> (!L.data)    <span class="comment">//考虑空间溢出时，这样判断</span></span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line"></span><br><span class="line">L.data = (<span class="type">int</span>*)<span class="built_in">ralloc</span>(L.data, <span class="built_in">sizeof</span>(<span class="type">int</span>)*(InitSize+<span class="number">10</span>)); <span class="comment">//不考虑溢出情况下，C版扩充写法</span></span><br></pre></td></tr></table></figure><h4 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>线性表的链式存储称为<strong>单链表</strong>，用<strong>一组任意的存储单元</strong>来存储线性表中的数据元素。</p><p>无论是否带头结点，<strong>头指针都始终指向链表的第一个结点</strong>，头结点的数据域很少存储信息，引入头结点可以有以下的优点：</p><ul><li>使得空表和非空表的处理得到统一。无论链表是否为空，头指针都指向头结点。</li><li>使得从开始结点到结束结点的每个位置上的操作一致。</li></ul><p>在<strong>循环单链表</strong>中，<strong>判空条件</strong>为：Head -&gt; next &#x3D;&#x3D; Head ，同时在任何一个位置上的插入和删除操作是<strong>等价</strong>的，不用判断是否在表尾。</p><p><strong>当操作常在表头和表尾进行时，对循环单链表仅设尾指针。</strong></p><h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><p>双链表结点类型描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DLNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DLNode</span> *next;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DLNode</span> *prior;</span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure><p>双链表使得访问后继结点和前驱结点的时间复杂度都为O(1)。</p><p>在<strong>循环双链表</strong>中，<strong>判空条件</strong>为：</p><ul><li>Head -&gt; next &#x3D;&#x3D; Head </li><li>或 Head -&gt; prior &#x3D;&#x3D; Head</li><li>或 上述条件的与</li></ul><h3 id="算法例题"><a href="#算法例题" class="headerlink" title="算法例题"></a>算法例题</h3><p>设$A &#x3D; (a_1,a_2, …, a_m)$和$B&#x3D;(b_1,b_2,…,b_n)$均为顺序表，$A’$和$B’$分别是除去最大公共前缀后的子表。例如，$A&#x3D;(b,e,i,j,i,n,g)$，$B&#x3D;(b,e,i,f,a,n,g)$，则两者的最大公共前缀为b、e、i，在两个顺序表中除去最大公共前缀后的子表分别为$A’&#x3D;(j,i,n,g)$，$B&#x3D;(f,a,n,g)$。若A’&#x3D;B’&#x3D;空表，则A&#x3D;B。若A’&#x3D;空表且B’≠空表，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A&lt;B，否则A&gt;B。试编写一个函数，根据上述方法比较A和B的大小，A和B中的元素为float型。</p><p>完整C++代码解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min 0.0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">float</span> A[],<span class="type">int</span> An,<span class="type">float</span> B[],<span class="type">int</span> Bn)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;An&amp;&amp;i&lt;Bn)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(A[i]-B[i])&lt;min)</span><br><span class="line">      ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;=An&amp;&amp;i&gt;=Bn)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((i&gt;=An&amp;&amp;i&lt;Bn)||A[i]&lt;B[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> A[maxSize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="type">float</span> B[maxSize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">compare</span>(A,<span class="number">4</span>,B,<span class="number">6</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个函数，<strong>逆序</strong>打印单链表中的数值，假设指针L指向了单链表的开始结点。</p><p>思路：分治策略</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reprint</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L！=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">reprint</span> (L-&gt;next);</span><br><span class="line">    cout&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该算法的时间和空间复杂度均为O(n)（打印数据点n次，保护现场的地方有n处，系统栈的深度为n）</strong>。</p><p>设有2个<strong>有序链表</strong>表示集合A和B，设计一个算法，判断他们是否相等。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEqual</span><span class="params">(LNode*A,LNode*B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode*p = A-&gt;next;</span><br><span class="line">  LNode*q = B-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==q-&gt;data)&#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p!=<span class="literal">NULL</span> || q!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点一：特性对比问题"><a href="#考点一：特性对比问题" class="headerlink" title="考点一：特性对比问题"></a>考点一：特性对比问题</h2><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h3><ul><li>线性表是一种逻辑结构，顺序表和链表指存储结构。</li><li>顺序表中元素的位序从1开始，而数组元素下标从0开始。</li><li>顺序表中，元素的逻辑顺序与其物理顺序相同，插入和删除通常需要移动大量元素。通常即插入或删除操作发生在表尾例外。</li><li>顺序表存储密度高，每个结点只存储数据元素。</li><li>单链表可以解决顺序表需要大量连续存储单元的缺点。</li><li>单链表附加指针域，也存在浪费空间的缺点。</li><li>双链表、循环单链表和循环双链表这些存储结构可以在仅知道链表中任一个结点地址的情况下推知其余所有结点的地址。</li><li>有时候还会给链表定义一个额外的指针，最常见的是表尾指针。</li><li>从表整体来看，一般顺序表存储空间利用率低于链表；而从单个存储单元来看，顺序表存储空间利用率要高于链表。</li></ul><h3 id="主观例题"><a href="#主观例题" class="headerlink" title="主观例题"></a>主观例题</h3><p>线性表可用顺序表或链表存储。试问：<br>1)如果有个表同时并存，并且在处理过程中各表的长度会动态发生变化，表的总数也可能自动改变，在此情况下，应选用哪种存储表示？为什么？<br>2)若表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，这时应采用哪种存储表示？为什么？</p><blockquote><p>1)采用链表。若采用顺序表，当表的长度动态变化时，频繁的删除和插入操作通常会涉及到较多的数据移动，浪费时间。同时在多个表并存的情况下，如果某个表有存满并溢出的情况，计算机很有可能采取紧凑操作，导致不断地把大片数据移来移去，容易出错且浪费时间。同时表的总数发生变化也会产生上述的麻烦。如果采用链表就会基本避免上述的问题。<br>2)采用顺序表。当表的总数基本稳定且很少进行插入和删除时，链表相对于顺序表的优势就会基本消失，而顺序表的存取速度快、存储利用率高的优点就会被充分发挥。</p></blockquote><h2 id="考点二：移动次数计算和静态链表"><a href="#考点二：移动次数计算和静态链表" class="headerlink" title="考点二：移动次数计算和静态链表"></a>考点二：移动次数计算和静态链表</h2><h3 id="移动次数计算"><a href="#移动次数计算" class="headerlink" title="移动次数计算"></a>移动次数计算</h3><p><strong>注意移动次数和平均移动次数的异同。</strong></p><p>顺序表中插入操作移动节点的平均次数，i代表插入位置：$$\sum_{i&#x3D;1}^{n+1} {1 \over n+1}(n-i+1) &#x3D;{n \over 2}$$</p><p>顺序表中插入操作移动节点的平均次数，i代表删除位置：$$\sum_{i&#x3D;1}^{n} {1 \over n}(n-i) &#x3D;{n-1 \over 2}$$</p><h3 id="静态链表（待补充）"><a href="#静态链表（待补充）" class="headerlink" title="静态链表（待补充）"></a>静态链表（待补充）</h3><p>静态链表<strong>借助数组</strong>来描述线性表的链式存储结构。</p><p>静态链表结点类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125;SLNode，SLinkList[maxSize];</span><br><span class="line"></span><br><span class="line">SLNode SLink[maxSize]; </span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">SLinkList SLink；</span><br></pre></td></tr></table></figure><p>这里的指针是结点的相对地址（数组下标），又称<strong>游标</strong>。其<strong>通常</strong>以next&#x3D;&#x3D;-1作为结束标志（或者为0），插入和删除操作与动态链表相同。</p><h2 id="考点三：插入删除"><a href="#考点三：插入删除" class="headerlink" title="考点三：插入删除"></a>考点三：插入删除</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>静态分配方式顺序表的插入函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertElem</span><span class="params">(<span class="type">int</span> sqList[],<span class="type">int</span> &amp;length,<span class="type">int</span> p,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;length || length==maxSize)  <span class="comment">//判断插入是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = length<span class="number">-1</span>; i &gt; p; --i)</span><br><span class="line">    sqList[i+<span class="number">1</span>] = sqList[i];</span><br><span class="line">  sqList[p] = e;</span><br><span class="line">  ++length;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：函数参数按照常规方法定义为数组，无需加“&amp;”符号，即可在函数体内直接改变所传入数组的元素值，可以理解为，只要函数参数定义为数组，就是定义的用型数组。</p></blockquote><p>顺序表的删除函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> sqList[],<span class="type">int</span> &amp;length,<span class="type">int</span> p,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;length<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  e = sqList[p];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = p; i&lt;length<span class="number">-1</span>; ++i)</span><br><span class="line">    sqList[i] = sqList[i+<span class="number">1</span>];</span><br><span class="line">  --length;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>通常链表的插入和删除需要找到插入和删除操作的前驱结点，其实换位思考也可以进行后插或者删除后继结点，主要区别在于交换结点的数值。不再列举插入和删除的举例代码，只强调结点的删除需要使用<strong>free()函数</strong>。</p><h3 id="算法例题-1"><a href="#算法例题-1" class="headerlink" title="算法例题"></a>算法例题</h3><ol><li>设计一个算法，从一给定的顺序表L中删除下标i~j（$i \leq j$ ，包括i、j）的所有元素，<strong>假定i、j都是合法的</strong>。</li></ol><p>主要函数解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span>&amp;length,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> k,delta;</span><br><span class="line">  delta = j-i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(k = j+<span class="number">1</span>;k&lt;length;++k)</span><br><span class="line">    arr[k-delta] = arr[k];</span><br><span class="line">  length-=delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>有一个<strong>递增非空单链表</strong>，设计一个算法删除值域重复的结点。例如，{1,1,2,3,3,3,4,4,7,7,7,9,9,9}经过删除后变成{1,2,3,4,7,9}。</li></ol><p>主要函数解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p=L-&gt;next,*q;</span><br><span class="line">  <span class="keyword">while</span> (p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==p-&gt;next-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//典型的单链表删除操作方法</span></span><br><span class="line">      q=p-&gt;next;</span><br><span class="line">      p-&gt;next=q-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点四：建表"><a href="#考点四：建表" class="headerlink" title="考点四：建表"></a>考点四：建表</h2><h3 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h3><p>建表算法代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[maxsize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createList</span> <span class="params">(<span class="type">int</span> A[],<span class="type">int</span> &amp;length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;length;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; maxSize)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)</span><br><span class="line">    cin&gt;&gt;A[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p><strong>尾插法</strong>建立单链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createLinkListR</span><span class="params">(LNode *&amp;head)</span></span>&#123;</span><br><span class="line">  head = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  head-&gt;next =  <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p = <span class="literal">NULL</span>,*r = head;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cin&gt;&gt;p-&gt;data;</span><br><span class="line">    p-&gt;next = r-&gt;next;</span><br><span class="line">    r-&gt;next = p;</span><br><span class="line">    r = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>头插法</strong>建立单链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ceateLinkListH</span><span class="params">(LNode *&amp;head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  head = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cin&gt;&gt;p-&gt;data;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法附设了一个指向表尾结点的指针。</p><h3 id="算法例题-2"><a href="#算法例题-2" class="headerlink" title="算法例题"></a>算法例题</h3><p>键盘输入n个英文字母，输入格式为n、c1、c2、… 、cn，其中n表示字母的个数。请编程以这些输入数据建立一个单链表，并要求将字母不重复地存入链表。</p><p>主要函数解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createLinkNoSameElem</span><span class="params">(LNode *&amp;head)</span></span>&#123;</span><br><span class="line">  head = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i <span class="number">0</span>;i n;++i)&#123;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;data == ch)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p = <span class="literal">NULL</span>)&#123;</span><br><span class="line">      p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">      p-&gt;data = ch;</span><br><span class="line">      p-&gt;next = head-&gt;next;</span><br><span class="line">      head-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点五：归并"><a href="#考点五：归并" class="headerlink" title="考点五：归并"></a>考点五：归并</h2><p>默认规则：两个递增有序线性表归并为一个递增有序线性表。</p><h3 id="顺序表归并"><a href="#顺序表归并" class="headerlink" title="顺序表归并"></a>顺序表归并</h3><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergearray</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> m,<span class="type">int</span> b[],<span class="type">int</span> n,<span class="type">int</span> c[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; m &amp;&amp;j &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]&lt;b[j])</span><br><span class="line">      c[k++]=a[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      c[k++]=b[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt; m)</span><br><span class="line">    c[k++]=a[i++];</span><br><span class="line">  <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">    c[k++]=b[j++];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表归并"><a href="#链表归并" class="headerlink" title="链表归并"></a>链表归并</h3><p>默认链表含有头结点。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p = A-&gt;next;</span><br><span class="line">  LNode *q = B-&gt;next;</span><br><span class="line">  LNode *r;</span><br><span class="line">  C=A;</span><br><span class="line">  C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">free</span>(B);<span class="comment">//记得释放其中一个头结点</span></span><br><span class="line">  r = C;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;q-&gt;data)&#123;</span><br><span class="line">      r-&gt;next = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      r-&gt;next = q;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">      r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) r-&gt;next = p;</span><br><span class="line">  <span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向归并，即将两个递增有序线性表归并为一个递减有序线性表，链表归并的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeR</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p = A-&gt;next;</span><br><span class="line">  LNode *q = B-&gt;next;</span><br><span class="line">  LNode *s;</span><br><span class="line">  C=A;</span><br><span class="line">  C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">free</span>(B);<span class="comment">//记得释放其中一个头结点</span></span><br><span class="line">  s = C;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;q-&gt;data)&#123;</span><br><span class="line">      s = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      s-&gt;next = C-&gt;next;</span><br><span class="line">      C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      s = q;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">      s-&gt;next = C-&gt;next;</span><br><span class="line">      C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    s = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    s-&gt;next = C-&gt;next;</span><br><span class="line">    C-&gt;next = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    s = q;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">    s-&gt;next = C-&gt;next;</span><br><span class="line">    C-&gt;next = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在顺序表的归并操作中，我们需要另外开辟存储空间，而在链表的归并中，我们只需新建一个头指针并更改指针的指向即可。</p><h2 id="考点六：逆置"><a href="#考点六：逆置" class="headerlink" title="考点六：逆置"></a>考点六：逆置</h2><h3 id="顺序表逆置"><a href="#顺序表逆置" class="headerlink" title="顺序表逆置"></a>顺序表逆置</h3><p>顺序表逆置过程需要辅助交换变量。示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = left, j = right; i &lt; j; ++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">  temp = a[i];</span><br><span class="line">  a[i] = a[j];</span><br><span class="line">  a[j]= temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><p>链表逆置的基本思路就是，依次取下前面的结点往后插入，即涉及到单链表的基本的插入和删除操作。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆置p-&gt;next到q的结点</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=q)</span><br><span class="line">&#123;</span><br><span class="line">  t = p-&gt;next;</span><br><span class="line">  p-&gt;next = t-&gt;next;</span><br><span class="line">  t-&gt;next = q-&gt;next;</span><br><span class="line">  q-&gt;next = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆置单链表L，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p = L-&gt;next,*q;</span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法例题-3"><a href="#算法例题-3" class="headerlink" title="算法例题"></a>算法例题</h3><ol><li>将一长度为n的数组的前端k(k&lt;n)个元素<strong>逆序</strong>后移动到数组后端，要求原数组中<strong>数据不丢失</strong>；</li></ol><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = left, j = right;i &lt; left+k &amp;&amp; i &lt; j; ++i,--j)&#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将一长度为n的数组的前端k(k&lt;n)个元素保持<strong>原序</strong>移动到数组后端，要求原数组中<strong>数据不丢失</strong>；</li></ol><p>这个题目可以不采用逆置的方法实现，给出的解决方案利用了第一问的函数。解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveToEnd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,k<span class="number">-1</span>,k);</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题解析"><a href="#真题解析" class="headerlink" title="真题解析"></a>真题解析</h3><p>设将n（n&gt;1）个整数存放到一维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&lt;p&lt;n)个位置，即将R中的元素$(X_0,X_1,…X_{n-1})$，经过移动后变为：$(X_p,X_{p+1},…X_{n-1},X_0,X_1,…X_{p-1})$。<br>要求：<br>(1)给出算法的基本设计思想。<br>(2)根据设计思想，采用C或C++或JAVA语言描述算法，关键之处给出注释。<br>(3)说明你所设计算法的时间复杂度和空间复杂度。</p><blockquote><p>(1)设计思想：将前面p个元素作为一个整体逆置，然后将后面n-p个元素作为一个整体逆置。最后将整个数组逆置，实现序列循环左移p个元素的操作。</p></blockquote><blockquote><p>(2)解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveP</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,p<span class="number">-1</span>,p);</span><br><span class="line">  <span class="built_in">reverse</span>(a,p,n<span class="number">-1</span>,n-p);</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,n<span class="number">-1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>(3)时间复杂度O(n)，辅助空间相对于输入数据量而言是常数，空间复杂度为O(1)。</p></blockquote><p><strong>Notes：</strong></p><ul><li>一次循环运行时间是循环内语句的运行时间乘以循环次数；</li><li>嵌套循环运行时间为最内层语句执行次数乘以总循环次数；</li><li>并列的两个循环运行时间与执行次数数量级大的那个相同。</li></ul><h2 id="考点七：取最值"><a href="#考点七：取最值" class="headerlink" title="考点七：取最值"></a>考点七：取最值</h2><p>该知识点容易与其他知识点结合出题。下述代码在取得最值的同时取得了最值的索引，符合大部分取最值的要求。</p><h3 id="顺序表-2"><a href="#顺序表-2" class="headerlink" title="顺序表"></a>顺序表</h3><p>取最大值代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (max&lt;a[i])&#123;</span><br><span class="line">    max = a[i];</span><br><span class="line">    maxIdx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取最小值代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> min = a[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (min&gt;a[i])&#123;</span><br><span class="line">    min = a[i];</span><br><span class="line">    minIdx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-2"><a href="#链表-2" class="headerlink" title="链表"></a>链表</h3><p>由于取最大值和取最小值代码类似，仅示例取最大值代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LNode *p,*q;</span><br><span class="line"><span class="type">int</span> max = head-&gt;next-&gt;data;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line">q = p;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(max &lt; p-&gt;data)&#123;</span><br><span class="line">    max = p-&gt;data;</span><br><span class="line">    q = p;</span><br><span class="line">  &#125;</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法例题-4"><a href="#算法例题-4" class="headerlink" title="算法例题"></a>算法例题</h3><p>一<strong>双链表</strong>非空，由head指针指出，结点结构为{llink,data,rlink},请设计一个将结点数据域data值最大的那个结点（<strong>最大值结点只有一个</strong>）移动到链表最前边的算法，要求不得申请新结点空间。</p><p>思路：找出最大值结点；“删除”最大值结点；插入最大值结点。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxFirst</span><span class="params">(DLNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DLNode *p = head-&gt;rlink,*q = p;</span><br><span class="line">  <span class="type">int</span> max = p-&gt;data;</span><br><span class="line">  <span class="comment">//找最值：</span></span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(max &lt; p-&gt;data)&#123;</span><br><span class="line">      max = p-&gt;data;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;rlink;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//&quot;删除”：</span></span><br><span class="line">  DLNode *l = q-&gt;llink,*r = q-&gt;rlink;</span><br><span class="line">  l-&gt;rlink = r;</span><br><span class="line">  <span class="keyword">if</span> (r!=<span class="literal">NULL</span>)</span><br><span class="line">    r-&gt;llink=l;</span><br><span class="line">  <span class="comment">//插入：</span></span><br><span class="line">  q-&gt;llink = head;</span><br><span class="line">  q-&gt;rlink = head-&gt;rlink;</span><br><span class="line">  head-&gt;rlink = q;</span><br><span class="line">  q-&gt;rlink-&gt;llink = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有N个<strong>个位正整数</strong>存放在int型数组A[0, … , N-1]中，N为已定义的常量且N$\leq$9，数组A[]的长度为N，另给一个int型变量i，要求**只用上述变量(A[0]~A[N-1]与i，这N+1个整型变量)**写一个算法，找出这N个整数中的最小者，并且要求不能破坏数组A[]中的数据。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i=A[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">whi1e</span>(i/<span class="number">10</span>&lt;=N<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">10</span>&gt;A[i/<span class="number">10</span>])&#123;</span><br><span class="line">      i = i-i%<span class="number">10</span>;</span><br><span class="line">      i = i+A[i/<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    i=i+<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  i=i%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题解析-1"><a href="#真题解析-1" class="headerlink" title="真题解析"></a>真题解析</h3><p>假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示。</p><img src="/img/数据结构/第二章_1.png" style="zoom:80%;" /><p>设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为{data,next}，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置（如图中字符i所在结点的位置p)。<br>要求：<br>1)给出算法的基本设计思想。<br>2)根据设计思想，采用C或C++或JAVA语音描述算法，关键之处给出注释。<br>3)说明你所设计算法的时间复杂度。</p><blockquote><p>1)分别求出str1和str2所指的两个链表的长度m和n。令指针p、q分别指向str1和str2的头结点，若m&gt;&#x3D;n，则使p指向链表中的第m-n+1个结点；若m&lt;n，则使q指向链表中的第n-m+1个结点；即使指针p和q所指的结点到表尾的长度相等。将指针p和q同步向后移动，并判断它们是否指向同一结点。若p和q指向同一结点，则该点即为所求的共同后缀的起始位置。</p></blockquote><blockquote><p>2)解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">findFristCommon</span><span class="params">(LNode *str1,LNode *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">  LNode *p = str1-&gt;next,*q = str2-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    len1++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    len2++;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (p=str1-&gt;next;len1&gt;len2;len1--)</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  <span class="keyword">for</span>(q=str2-&gt;next;len1&lt;len2;len2--)</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;p!=q)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>3)时间复杂度为O(n)。</p></blockquote><h2 id="考点八：划分"><a href="#考点八：划分" class="headerlink" title="考点八：划分"></a>考点八：划分</h2><p>划分规则：以某个元素为标准，将线性表划分为左右两部分。这个标准一般称为枢轴，往年题型可以分为以下三种：以第一个元素为枢轴将顺序表划分； 设定比较标准将顺序表划分为左右两部分；以数组元素中任何一个元素作为枢轴进行划分。</p><h3 id="以第一个元素为枢轴将顺序表划分"><a href="#以第一个元素为枢轴将顺序表划分" class="headerlink" title="以第一个元素为枢轴将顺序表划分"></a>以第一个元素为枢轴将顺序表划分</h3><p>第一个元素为枢轴，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span> <span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>;</span><br><span class="line">  temp = arr[i];</span><br><span class="line">  <span class="comment">//始终判断i是否小于j</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= temp) --j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      ++i:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; temp) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设定比较标准将顺序表划分为左右两部分"><a href="#设定比较标准将顺序表划分为左右两部分" class="headerlink" title="设定比较标准将顺序表划分为左右两部分"></a>设定比较标准将顺序表划分为左右两部分</h3><p>第一个元素为枢轴，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span> <span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n,<span class="type">int</span> comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>;</span><br><span class="line">  temp = arr[i];</span><br><span class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= comp) --j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      ++i:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; comp) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当设置temp：X；comp：Y时：</p><ul><li>效果是把数组元素以Y为界限分成了前后两部分，前半部分小于Y，后半部分大于等于Y;</li><li>i和j最终指向的值是X，而不是Y。</li></ul><h3 id="以数组元素中任何一个元素作为枢轴进行划分"><a href="#以数组元素中任何一个元素作为枢轴进行划分" class="headerlink" title="以数组元素中任何一个元素作为枢轴进行划分"></a>以数组元素中任何一个元素作为枢轴进行划分</h3><p>以k位置上的元素作为枢轴，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span> <span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>;</span><br><span class="line">  temp = arr[<span class="number">0</span>];</span><br><span class="line">  arr[<span class="number">0</span>] = arr[k];</span><br><span class="line">  arr[k] = temp;</span><br><span class="line">  temp = arr[i];</span><br><span class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= temp) --j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      ++i:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; temp) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>2023王道考研数据结构书籍</p><p><a href="https://www.bilibili.com/video/BV1C84y1q7LA?p=1&vd_source=fc6821318d7aa4e7bbf228b7bf4bd30f">2024天勤考研数据结构基础课</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习总结 | 第一期 | 绪论</title>
      <link href="/posts/ceb59870.html"/>
      <url>/posts/ceb59870.html</url>
      
        <content type="html"><![CDATA[<h2 id="复习重点"><a href="#复习重点" class="headerlink" title="复习重点"></a>复习重点</h2><p>该章复习主要掌握<strong>算法概念</strong>、深入理解<strong>逻辑结构和存储结构的关系</strong>、认清<strong>什么是数据结构</strong>和学会<strong>对算法分析其时间和空间复杂度</strong>。其中对算法的分析尤为重要，是历年考试的重点。</p><h2 id="逻辑结构和存储结构"><a href="#逻辑结构和存储结构" class="headerlink" title="逻辑结构和存储结构"></a>逻辑结构和存储结构</h2><p><strong>Notes：</strong></p><ul><li>逻辑结构是指数据元素之间的逻辑关系，独立于计算机，与数据的存储无关。</li><li>笼统地讲，逻辑结构有四种：“没关系”，“一对一”，“一对多”，“多对多”。简单地讲对应于集合，线性结构，树形结构，图状结构和网状结构。</li><li>存储结构，也称为物理结构，它包括数据元素及其关系的表示，指数据结构在计算机中的表示或映像（或计算机语言实现逻辑结构）。</li><li>存储结构主要包括：顺序存储、链式存储、索引存储和散列存储。重点在顺序和链式存储。顺序结构支持随机存取（Random Access），而链式结构只能实现顺序存取。链式结构重点代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line">LNode *L;</span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">A-&gt;next = B;</span><br><span class="line">B-&gt;next = C;</span><br></pre></td></tr></table></figure><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p><strong>Notes:</strong></p><ul><li>数据结构包括三方面：逻辑结构、存储结构和数据的运算（基本操作集）。运算的定义是针对逻辑结构的，指明其功能；运算的实现是针对存储结构的，指出具体步骤。</li><li>算法（Algorithm）是对特定问题求解步骤的一种描述，≠程序，且必须具备有穷性、确定性和可行性（其他特性：输入和输出）。</li><li>算法的时间复杂度不仅依赖于问题的规模<em>n</em>，也取决于待输入数据的性质（如输入数据元素的初始状态）。</li><li>算法的设计取决于所选定的逻辑结构，算法的实现依赖于所采用的存储结构。</li></ul><h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><p><strong>Notes：</strong></p><ul><li><p>时间和空间复杂度是对算法效率的度量。算法中所有语句的频度之和记为T(n)，时间复杂度就是分析其数量级。通常采用算法中的基本运算的频度f(n)来分析算法的时间复杂度：T(n)&#x3D;O(f(n))。</p></li><li><p>时间复杂度的一些规则和公式：</p><p>a) 加法规则：$$T(n)&#x3D;T_1(n)+T_2(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max(f(n),g(n)))$$</p><p>b) 乘法规则：$$T(n)&#x3D;T_1(n)×T_2(n)&#x3D;O(f(n))×O(g(n))&#x3D;O(f(n)×g(n))$$</p><p>c) 特定情况下简化计算的公式：</p><img src="/img/tupian.png" width="60%" height="60%" /><p>d) 常见的渐近时间复杂度：$$ \small O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) $$</p></li><li><p>空间复杂度S(n)定义为该算法所耗费的存储空间，是问题规模n的函数。</p></li><li><p>算法原地工作是指算法所需的辅助空间为常量，即O(1)。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>除夕夜前，自己的第一个博客出炉</title>
      <link href="/posts/ee9e06b0.html"/>
      <url>/posts/ee9e06b0.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​作为一名计算机专业的学生，总觉得自己应该有一个blog，同时还在网上看到了许多精美的个人blog，因此这个博客就诞生了（庆祝！！！）。这个博客的搭建是利用hexo框架+github搭建起来的，基本没有用到什么前端的知识（前端小白就可以搭建），有搭建想法的朋友可以参考<a href="https://anzhiy.cn/posts/ddae.html">保姆级教程</a>。</p><p>我之后会尽量持续更新和维护博客，或许不久后会加入评论系统，欢迎有兴趣的朋友持续关注哇。要是github托管下网速过于不稳定，之后可能会考虑利用服务器。</p><h2 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h2><p>​最后祝大家除夕夜快乐！！！</p><p>送给大家一个除夕<a href="../firework.html">烟火秀</a>。如果没有声音或过于卡顿，可以点<a href="https://cantelope.org/NYE/">此</a>欣赏。烟火秀的代码是在github开源代码上做了部分修改，有兴趣的朋友可以点击<a href="https://github.com/SakuraLQY/FireWorks">源码</a>链接自行查看github上的开源代码。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>

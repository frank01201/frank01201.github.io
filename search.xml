<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统 | 第一章 | 概述</title>
      <link href="/posts/83804f68.html"/>
      <url>/posts/83804f68.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题意识"><a href="#问题意识" class="headerlink" title="问题意识"></a>问题意识</h2><p>我们将从以下几个问题串联起整章的结构：</p><ol><li>什么是操作系统？</li><li>操作系统有哪些功能？</li><li>操作系统有哪些特征？</li><li>操作系统是怎么发展过来的？</li><li>操作系统的运行机制是怎样的？</li><li>操作系统的结构是怎样设计的？</li></ol><p>本章通常以<strong>选择题</strong>形式考察，重点考察操作系统的功能、运行环境和提供的服务。</p><h2 id="操作系统的概念和作用"><a href="#操作系统的概念和作用" class="headerlink" title="操作系统的概念和作用"></a>操作系统的概念和作用</h2><p>操作系统（Operation System），简称OS，是管理计算机<strong>『硬件』</strong>与<strong>『软件』</strong>资源的<strong>计算机程序</strong>。</p><p>OS是一种<strong>系统软件</strong>，它的主要作用有以下几点：</p><ul><li>管理与配置内存</li><li>决定系统资源供需的优先次序</li><li>控制输入设备与输出设备</li><li>操作网络与管理文件系统等基本事务</li><li>提供一个让用户与系统交互的操作界面</li></ul><h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><p>配置OS的目标和OS的功能：</p><ol><li><p>管理系统资源（作为计算机系统资源的管理者，包括处理机、存储器、I&#x2F;O设备和文件管理）</p><ul><li><strong>有效性</strong>：提高系统资源利用率；提高系统的吞吐量；</li></ul></li><li><p>方便用户使用（作为用户与计算机硬件系统之间的接口，包括程序接口、命令接口和图形用户接口（Graphical User Interface））</p><ul><li>联机命令接口，又称交互式命令接口，适用于分时或实时系统的接口。</li><li>脱机命令接口，又称批处理命令接口，适用于批处理系统。</li><li>程序接口由一组系统调用（广义指令）组成。GUI通过调用程序接口实现的，并不是操作系统的一部分。</li></ul></li><li><p>作为扩充机器（实现了对计算机资源的抽象，将具体的计算机硬件资源抽象成软件资源）</p><ul><li><p>可扩充性：方便用户使用和扩展</p></li><li><p>开放性：<strong>开放了简单的访问方式，隐藏了实现细节</strong></p></li><li><p>扩充机器指覆盖了软件的机器。</p><p>  如：使用浏览器搜索</p></li></ul><img src="/img/操作系统/浏览器搜索.png" style="zoom:40%;" /></li></ol><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><img src="/img/操作系统/OS1_2.png" style="zoom:40%;" /><h3 id="并发（重要）"><a href="#并发（重要）" class="headerlink" title="并发（重要）"></a>并发（重要）</h3><p>概念：同一<strong>时间间隔</strong>内执行和调度<strong>多个程序</strong>的能力。</p><p>特点：</p><ul><li>宏观上，处理机同时执行多道程序</li><li>微观上，处理机在多道程序间高速切换（<strong>分时交替执行</strong>）</li><li>关注单个处理机同一时间段内处理任务数量的能力</li></ul><p>并发和并行的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">并发：同一**时间间隔（时间段）**发生的事件数量</span><br><span class="line"></span><br><span class="line">并行：同一**时刻（时间点）**发生的事件数量</span><br><span class="line"></span><br><span class="line">并行性具有明显的物理极限。</span><br></pre></td></tr></table></figure><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>概念：即资源共享，系统中的资源供多个『并发执行』的应用程序共同使用。</p><ul><li>同时访问方式：同一时段允许多个程序同时访问共享资源。</li><li>互斥共享方式：也叫独占式，允许多个程序在同一个共享资源上独立而互不干扰的工作。这种资源称为临界资源。<ul><li>一般示例：共享打印机、音频设备、视频设备</li></ul></li></ul><p><strong>并发和共享互为存在条件：</strong></p><ul><li>共享性要求OS中同时运行着多道程序，即要求有并发性。<ul><li>若只有单道程序正在运行，则不存在共享的可能。</li></ul></li><li>并发性难以避免的导致多道程序同时访问同一个资源，即要求有共享性。<ul><li>若多道程序无法共享部分资源（比如磁盘），则无法并发。</li></ul></li></ul><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>概念：使用某种技术把一个物理实体变成多个逻辑上的对应物。</p><p>虚拟技术（Virtual）主要有以下两种：</p><ul><li>时分复用技术（TDM，Time Division Multiplexing）<ul><li>虚拟处理机技术：“四核八线程”</li><li>虚拟设备技术：虚拟打印机</li></ul></li><li>空分复用技术（SDM，Space Division Multiplexing）<ul><li>虚拟磁盘技术：将一块硬盘虚拟出若干个卷</li><li>虚拟存储器技术</li></ul></li></ul><p>两类技术之间并不是同时存在的，它们之间是或的关系。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>多道程序环境下，允许多个程序并发执行；单处理机环境下，多个程序分时交替执行。</p><p>由于程序执行的<strong>不可预知性</strong>导致了OS的异步性（Asynchronism）。</p><ul><li>不可预知性的体现：获得运行的时机；因何暂停；每道程序需要多少时间；不同程序的性能；</li><li>宏观上“一气呵成”，微观上“走走停停”。</li></ul><p>异步性使得操作系统运行在一种<strong>随机的环境</strong>下，可能导致进程产生与时间有关的错误。</p><h2 id="操作系统发展历程"><a href="#操作系统发展历程" class="headerlink" title="操作系统发展历程"></a>操作系统发展历程</h2><img src="/img/操作系统/OS1_3.png" style="zoom:40%;" /><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p>该阶段没有操作系统，所有工作需要人工干预。</p><p>人工操作方式突出的两个缺点是：<strong>用户独占全机；CPU等待手工操作</strong>。</p><p>脱机输入&#x2F;输出方式的特点：解决了人机矛盾；减少了CPU的空闲时间；提高了I&#x2F;O速度；<strong>一次只能执行一个程序</strong>。</p><h3 id="批处理阶段（同时处理多道程序）"><a href="#批处理阶段（同时处理多道程序）" class="headerlink" title="批处理阶段（同时处理多道程序）"></a>批处理阶段（同时处理多道程序）</h3><p>操作系统开始出现，为解决人机矛盾和I&#x2F;O设备之间速度不匹配的矛盾，分为单道批处理系统（OS前身）、多道批处理系统（多道程序设计技术出现后）。</p><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>对作业的处理是成批进行的，但内存中<strong>始终保持一道作业</strong>。面临的问题是，每次<strong>监督程序</strong>只调入一道程序进入内存，在运行期间（<strong>运行时，不是完成后</strong>）主机每次发出输入&#x2F;输出请求后，高速<strong>CPU要等待低速的I&#x2F;O完成</strong>。</p><p>主要特征：<strong>自动性；顺序性；单道性</strong>。</p><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>多道程序设计技术允许<strong>多个程序同时进入内存</strong>并允许它们在<strong>CPU中交替地运行</strong>（调度程序自动选择作业运行），这些程序<strong>共享</strong>系统中的各种硬&#x2F;软件资源。</p><p><strong>主要特点</strong>：提高CPU的利用率；提高内存和I&#x2F;O设备利用率；增加系统吞吐量；平均周转时间长（用户响应时间长）；没有人机交互；</p><blockquote><p>单道批处理系统：主要解决CPU、内存和I&#x2F;O设备利用率不足的问题<br>多道批处理系统：主要解决I&#x2F;O操作时CPU闲置问题</p></blockquote><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>分时操作系统是指<strong>多个用户</strong>通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而不相互干扰。而分时技术是指把处理器的运行时间分成很短的<strong>时间片</strong>，按时间片分配处理器。</p><blockquote><p>分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统。</p></blockquote><p>需要分时操作系统的原因：实现<strong>人机交互</strong>；共享主机；便于用户上机。</p><p>需要解决的关键问题是：<strong>及时</strong>接收；<strong>及时</strong>处理（作业提前进入内存，并能够与用户交互）。</p><p>主要特征：</p><ul><li>同时性（多路性）：时间片轮转实现多个用户同时使用计算机；</li><li>独立性：用户彼此独立互不干扰；</li><li>及时性：用户可以在较短时间内获得响应；</li><li>交互性：用户可以控制并请求多种服务；</li></ul><p>主要缺点：作业&#x2F;用户优先级相同，不能优先处理紧急任务（该任务规定时间比时间片时间还短）</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>在某个时间限制内完成某些紧急任务而不需要时间片排队，即能够<strong>即时</strong>响应外部事件的请求。但是其交互性不如分时系统。</p><p>需要实时操作系统的原因：实现实时控制和实时信息处理。</p><p>实时任务的分类：</p><ul><li>周期&#x2F;非周期性实时任务（根据周期性）</li><li>硬&#x2F;软实时任务（根据截止时间）<ul><li>若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为<strong>硬实时系统</strong>，如飞行器的飞行自动控制系统。</li><li>若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为<strong>软实时系统</strong>，如飞机订票系统、银行管理系统。</li></ul></li></ul><p>与分时操作系统比较，还有两个主要特点：</p><ul><li>及时性：以用户能接受的等待时间为准；</li><li><strong>可靠性</strong>：多级容错，保障系统和数据的安全；</li></ul><h3 id="网络操作系统与分布式操作系统"><a href="#网络操作系统与分布式操作系统" class="headerlink" title="网络操作系统与分布式操作系统"></a>网络操作系统与分布式操作系统</h3><p>网络操作系统最主要的特点是：网络中各种资源的共享及各台计算机之间的通信。</p><p>分布式计算机系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统的本质不同是，<strong>分布式操作系统中的若干计算机相互协同完成同一任务</strong>。</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS1_4.png" alt="操作系统发展历程"></p><p>推动操作系统发展的动力：</p><ul><li>不断提高计算机资源的利用率</li><li>方便用户</li><li>器件的不断更新换代</li><li>计算机体系结构的不断发展</li></ul><h2 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h2><p>计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统<strong>内核程序</strong>；另一种是<br><strong>应用程序</strong>。对应着来说，在具体实现上，CPU运行模式可分为<strong>用户态（目态）</strong>和<strong>核心态（又称管态、内核态）</strong>。<strong>CPU处于用户态下只能执行非特权指令；当CPU处于核心态时可以执行除了访管指令以外的全部指令</strong>。</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS1_5.png" alt="指令分类"></p><p>大多数操作系统的内核包括4方面的内容：时钟管理、中断机制、原语、系统控制的数据结构及处理。</p><h3 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h3><p>在计算机各种部件中，时钟是最关键的设备。</p><ul><li>计时：提供系统时间</li><li>时钟中断：实现进程切换</li></ul><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>中断技术的初衷：提高多道程序环境下的CPU利用率。中断机制不断发展形成多种类型，可以说，现代操作系统是靠中断驱动的软件。中断机制中只有一小部分功能属于内核。</p><ul><li>外中断：中断信号来源于-&gt;<strong>外部设备</strong></li><li>内中断：中断信号来源于-&gt;<strong>当前指令</strong></li></ul><p>外中断两种情况：</p><ul><li>可屏蔽中断 INTR</li><li>不可屏蔽中断 NMI</li></ul><p>内中断（异常&#x2F;陷入&#x2F;例外）三种情况：</p><ul><li>陷阱&#x2F;陷入&#x2F;自陷（Trap）：由<strong>应用程序主动引发</strong></li><li>故障（fault）：由错误条件引发</li><li>终止（abort）：由致命错误引发</li></ul><p>故障异常和自陷异常属于<strong>软件中断(程序性异常)<strong>，终止异常和外部中断属于</strong>硬件中断</strong>。异常不能被屏蔽，一旦出现，就应立即处理。</p><p>中断和异常处理过程包括：中断或异常处理程序；中断或异常返回指令。</p><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>原语是一个由若干条指令组成的<strong>程序段</strong>，可用于<strong>完成规定操作</strong>的公用小程序。</p><ul><li>具有<strong>“原子性”</strong>，执行不可被中断；</li><li>处于OS最底层，运行在<strong>内核空间</strong>；</li><li>运行时间都较短，调用频繁；</li></ul><p>定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</p><h3 id="系统数据结构"><a href="#系统数据结构" class="headerlink" title="系统数据结构"></a>系统数据结构</h3><p>一般只涉及到对数据结构的操作，不涉及硬件。</p><ul><li>进程管理：作业控制块、进程控制块（PCB）；</li><li>存储器管理：存储器分配与回收；</li><li>设备管理：缓冲区、设备控制块；</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用的处理需要由操作系统内核程序负责完成，要<strong>运行在核心态</strong>。</p><ul><li>可被视为公共子程序，是一套接口的集合（涉及到系统资源管理、进程管理之类的操作）；</li><li>由操作系统实现，给应用程序调用，是应用程序访问内核服务的一种方式（用户程序可以执行陷入指令来发起系统调用，请求操作系统提供服务）；</li></ul><p>若程序的运行由用户态转到核心态，则会用到访管指令，<strong>访管指令</strong>是在用户态使用的，所以它<strong>不可能是特权指令</strong>。 </p><h2 id="操作系统结构设计"><a href="#操作系统结构设计" class="headerlink" title="操作系统结构设计"></a>操作系统结构设计</h2><img src="/img/操作系统/OS1_6.png" alt="操作系统结构" style="zoom:50%;" /><h3 id="传统的操作系统结构（大内核）"><a href="#传统的操作系统结构（大内核）" class="headerlink" title="传统的操作系统结构（大内核）"></a>传统的操作系统结构（大内核）</h3><p>在内核架构中，大内核也称单内核或宏内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p><h4 id="第一代：无结构OS"><a href="#第一代：无结构OS" class="headerlink" title="第一代：无结构OS"></a>第一代：无结构OS</h4><ul><li>一系列过程（程序）的集合，过程间可以相互调用</li><li>结构复杂且混乱，难以调试、阅读和维护</li></ul><h4 id="第二代：模块化结构OS-：模块-接口法OS"><a href="#第二代：模块化结构OS-：模块-接口法OS" class="headerlink" title="第二代：模块化结构OS ：模块-接口法OS"></a>第二代：模块化结构OS ：模块-接口法OS</h4><p>基于“分解”和“模块化”原则，按照功能划分模块&#x2F;子模块，并规定模块间的接口。</p><p><strong>模块独立性标准：高内聚、低耦合</strong>。</p><ul><li>内聚性，模块内部各部分间联系的紧密程度。</li><li>耦合度，模块间相互联系和相互影响的程度。</li></ul><p>优点：</p><ul><li>提高OS设计的正确性、可理解性和可维护性；</li><li>增强OS的适应性；</li><li>加速开发过程；</li></ul><p>缺点：</p><ul><li>模块接口设计难以扩展后续需求</li><li>各模块设计没有统一的决策标准，导致模块接口设计不可靠</li></ul><h4 id="第三代：分层式结构OS"><a href="#第三代：分层式结构OS" class="headerlink" title="第三代：分层式结构OS"></a>第三代：分层式结构OS</h4><p>有序分层法，自顶向下依次依赖（每层只能调用紧邻它的低层的功能和服务（单向依赖））。设计时，自底向上：每一步建立在可靠的基础上。</p><p>优缺点：</p><ul><li>容易保证系统正确性；</li><li>容易扩充和维护；</li><li>自上而下的层次通信，导致系统效率降低；</li><li>依赖关系固定后，合理定义各层比较困难；</li></ul><h3 id="第四代：微内核OS结构"><a href="#第四代：微内核OS结构" class="headerlink" title="第四代：微内核OS结构"></a>第四代：微内核OS结构</h3><p>微内核构架，是指将内核中最基本的功能保留在内核。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。<strong>足够小的内核，只实现OS核心功能。</strong></p><p>微内核通常包含：</p><ul><li>与硬件处理紧密相关的部分，比如硬件处理；</li><li>一些较基本的功能；</li><li>客户和服务器之间通信（客户&#x2F;服务器模式）；</li></ul><p>多个服务器都是作为进程来实现的，运行在用户态。微内核采用<strong>面向对象的技术</strong>，应用<strong>“机制与策略分离”</strong>原理来构造OS结构，将机制部分以及与硬件紧密相关的部分放入微内核。</p><p>优点：</p><ul><li>提高OS的可扩展性、可靠性、可移植性；</li><li>支持分布式系统（通信采用信息传递机制）；</li><li>融入了面向对象技术；</li></ul><p>缺点：用户态和核心态之间的频繁切换降低了效率。</p><p>虽然宏内核在桌面操作系统中取得了绝对的胜利，但是微内核在实时、工业、航空及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>2023年王道操作系统考研复习指导<br><a href="https://www.bilibili.com/video/BV1vd4y1s7KV?p=1&vd_source=fc6821318d7aa4e7bbf228b7bf4bd30f">彭彭学编程UP主操作系统第一章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习总结 | 第二期 | 线性表</title>
      <link href="/posts/d195e58.html"/>
      <url>/posts/d195e58.html</url>
      
        <content type="html"><![CDATA[<h2 id="【复习重点】"><a href="#【复习重点】" class="headerlink" title="【复习重点】"></a>【复习重点】</h2><p>线性表是<strong>算法题命题的重点</strong>，其实现要求具有一定的性能。算法最重要的是<strong>思想</strong>，尽力表达算法的思想和步骤。在明确线性表<strong>定义</strong>的基础上掌握线性表的<strong>逻辑结构</strong>和<strong>存储结构</strong>，然后再掌握各种<strong>基本操作</strong>（最核心、最基本的操作）。</p><p>在研究生入学考试中，线性表的考察主要有以下<strong>八大考点</strong>：<strong>特性对比问题、移动次数计算和静态链表、插入删除、归并、建表、逆置、划分和取最值</strong>。</p><h2 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h2><p>线性表是具有<strong>相同特性</strong>数据元素的<strong>有限序列</strong>。</p><ul><li>相同特性：将同一类事物归类，方便批量处理。</li><li>有限：表中元素个数为n，n有限大，n可以为0。</li><li>序列：表中元素排成一列，体现一对一的逻辑特性（每个元素有则仅有一个前驱和一个后继）。</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>线性表的顺序存储称作<strong>顺序表</strong>，用<strong>一组地址连续的存储单元依次存储</strong>线性表中的数据元素。我们常用数组来描述顺序表，一维的数组可以<strong>静态分配</strong>，也可以<strong>动态分配</strong>。</p><p>静态分配的代码演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> data[MaxSize];</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">SqList L;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>动态分配代码演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> *data;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">SqList L;</span><br><span class="line"><span class="comment">//C初始动态分配语句</span></span><br><span class="line">L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*InitSize);</span><br><span class="line"><span class="comment">//C++初始动态分配语句</span></span><br><span class="line">L.data = <span class="keyword">new</span> <span class="type">int</span>[InitSize];</span><br><span class="line"><span class="keyword">if</span> (!L.data)    <span class="comment">//考虑空间溢出时，这样判断</span></span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">L.MaxSize = InitSize;</span><br><span class="line"></span><br><span class="line">L.data = (<span class="type">int</span>*)<span class="built_in">ralloc</span>(L.data, <span class="built_in">sizeof</span>(<span class="type">int</span>)*(InitSize+<span class="number">10</span>)); <span class="comment">//不考虑溢出情况下，C版扩充写法</span></span><br></pre></td></tr></table></figure><h4 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>线性表的链式存储称为<strong>单链表</strong>，用<strong>一组任意的存储单元</strong>来存储线性表中的数据元素。</p><p>无论是否带头结点，<strong>头指针都始终指向链表的第一个结点</strong>，头结点的数据域很少存储信息，引入头结点可以有以下的优点：</p><ul><li>使得空表和非空表的处理得到统一。无论链表是否为空，头指针都指向头结点。</li><li>使得从开始结点到结束结点的每个位置上的操作一致。</li></ul><p>在<strong>循环单链表</strong>中，<strong>判空条件</strong>为：Head -&gt; next &#x3D;&#x3D; Head ，同时在任何一个位置上的插入和删除操作是<strong>等价</strong>的，不用判断是否在表尾。</p><p><strong>当操作常在表头和表尾进行时，对循环单链表仅设尾指针。</strong></p><h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><p>双链表结点类型描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DLNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DLNode</span> *next;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">DLNode</span> *prior;</span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure><p>双链表使得访问后继结点和前驱结点的时间复杂度都为O(1)。</p><p>在<strong>循环双链表</strong>中，<strong>判空条件</strong>为：</p><ul><li>Head -&gt; next &#x3D;&#x3D; Head </li><li>或 Head -&gt; prior &#x3D;&#x3D; Head</li><li>或 上述条件的与</li></ul><h3 id="算法例题"><a href="#算法例题" class="headerlink" title="算法例题"></a>算法例题</h3><p>设$A &#x3D; (a_1,a_2, …, a_m)$和$B&#x3D;(b_1,b_2,…,b_n)$均为顺序表，$A’$和$B’$分别是除去最大公共前缀后的子表。例如，$A&#x3D;(b,e,i,j,i,n,g)$，$B&#x3D;(b,e,i,f,a,n,g)$，则两者的最大公共前缀为b、e、i，在两个顺序表中除去最大公共前缀后的子表分别为$A’&#x3D;(j,i,n,g)$，$B&#x3D;(f,a,n,g)$。若A’&#x3D;B’&#x3D;空表，则A&#x3D;B。若A’&#x3D;空表且B’≠空表，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A&lt;B，否则A&gt;B。试编写一个函数，根据上述方法比较A和B的大小，A和B中的元素为float型。</p><p>完整C++代码解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min 0.0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">float</span> A[],<span class="type">int</span> An,<span class="type">float</span> B[],<span class="type">int</span> Bn)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;An&amp;&amp;i&lt;Bn)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(A[i]-B[i])&lt;min)</span><br><span class="line">      ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;=An&amp;&amp;i&gt;=Bn)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((i&gt;=An&amp;&amp;i&lt;Bn)||A[i]&lt;B[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> A[maxSize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="type">float</span> B[maxSize]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">compare</span>(A,<span class="number">4</span>,B,<span class="number">6</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个函数，<strong>逆序</strong>打印单链表中的数值，假设指针L指向了单链表的开始结点。</p><p>思路：分治策略</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reprint</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L！=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">reprint</span> (L-&gt;next);</span><br><span class="line">    cout&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该算法的时间和空间复杂度均为O(n)（打印数据点n次，保护现场的地方有n处，系统栈的深度为n）</strong>。</p><p>设有2个<strong>有序链表</strong>表示集合A和B，设计一个算法，判断他们是否相等。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isEqual</span><span class="params">(LNode*A,LNode*B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode*p = A-&gt;next;</span><br><span class="line">  LNode*q = B-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==q-&gt;data)&#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p!=<span class="literal">NULL</span> || q!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点一：特性对比问题"><a href="#考点一：特性对比问题" class="headerlink" title="考点一：特性对比问题"></a>考点一：特性对比问题</h2><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h3><ul><li>线性表是一种逻辑结构，顺序表和链表指存储结构。</li><li>顺序表中元素的位序从1开始，而数组元素下标从0开始。</li><li>顺序表中，元素的逻辑顺序与其物理顺序相同，插入和删除通常需要移动大量元素。通常即插入或删除操作发生在表尾例外。</li><li>顺序表存储密度高，每个结点只存储数据元素。</li><li>单链表可以解决顺序表需要大量连续存储单元的缺点。</li><li>单链表附加指针域，也存在浪费空间的缺点。</li><li>双链表、循环单链表和循环双链表这些存储结构可以在仅知道链表中任一个结点地址的情况下推知其余所有结点的地址。</li><li>有时候还会给链表定义一个额外的指针，最常见的是表尾指针。</li><li>从表整体来看，一般顺序表存储空间利用率低于链表；而从单个存储单元来看，顺序表存储空间利用率要高于链表。</li></ul><h3 id="主观例题"><a href="#主观例题" class="headerlink" title="主观例题"></a>主观例题</h3><p>线性表可用顺序表或链表存储。试问：<br>1)如果有个表同时并存，并且在处理过程中各表的长度会动态发生变化，表的总数也可能自动改变，在此情况下，应选用哪种存储表示？为什么？<br>2)若表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，这时应采用哪种存储表示？为什么？</p><blockquote><p>1)采用链表。若采用顺序表，当表的长度动态变化时，频繁的删除和插入操作通常会涉及到较多的数据移动，浪费时间。同时在多个表并存的情况下，如果某个表有存满并溢出的情况，计算机很有可能采取紧凑操作，导致不断地把大片数据移来移去，容易出错且浪费时间。同时表的总数发生变化也会产生上述的麻烦。如果采用链表就会基本避免上述的问题。<br>2)采用顺序表。当表的总数基本稳定且很少进行插入和删除时，链表相对于顺序表的优势就会基本消失，而顺序表的存取速度快、存储利用率高的优点就会被充分发挥。</p></blockquote><h2 id="考点二：移动次数计算和静态链表"><a href="#考点二：移动次数计算和静态链表" class="headerlink" title="考点二：移动次数计算和静态链表"></a>考点二：移动次数计算和静态链表</h2><h3 id="移动次数计算"><a href="#移动次数计算" class="headerlink" title="移动次数计算"></a>移动次数计算</h3><p><strong>注意移动次数和平均移动次数的异同。</strong></p><p>顺序表中插入操作移动节点的平均次数，i代表插入位置：$$\sum_{i&#x3D;1}^{n+1} {1 \over n+1}(n-i+1) &#x3D;{n \over 2}$$</p><p>顺序表中插入操作移动节点的平均次数，i代表删除位置：$$\sum_{i&#x3D;1}^{n} {1 \over n}(n-i) &#x3D;{n-1 \over 2}$$</p><h3 id="静态链表（待补充）"><a href="#静态链表（待补充）" class="headerlink" title="静态链表（待补充）"></a>静态链表（待补充）</h3><p>静态链表<strong>借助数组</strong>来描述线性表的链式存储结构。</p><p>静态链表结点类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125;SLNode，SLinkList[maxSize];</span><br><span class="line"></span><br><span class="line">SLNode SLink[maxSize]; </span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">SLinkList SLink；</span><br></pre></td></tr></table></figure><p>这里的指针是结点的相对地址（数组下标），又称<strong>游标</strong>。其<strong>通常</strong>以next&#x3D;&#x3D;-1作为结束标志（或者为0），插入和删除操作与动态链表相同。</p><h2 id="考点三：插入删除"><a href="#考点三：插入删除" class="headerlink" title="考点三：插入删除"></a>考点三：插入删除</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>静态分配方式顺序表的插入函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertElem</span><span class="params">(<span class="type">int</span> sqList[],<span class="type">int</span> &amp;length,<span class="type">int</span> p,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;length || length==maxSize)  <span class="comment">//判断插入是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = length<span class="number">-1</span>; i &gt; p; --i)</span><br><span class="line">    sqList[i+<span class="number">1</span>] = sqList[i];</span><br><span class="line">  sqList[p] = e;</span><br><span class="line">  ++length;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：函数参数按照常规方法定义为数组，无需加“&amp;”符号，即可在函数体内直接改变所传入数组的元素值，可以理解为，只要函数参数定义为数组，就是定义的用型数组。</p></blockquote><p>顺序表的删除函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> sqList[],<span class="type">int</span> &amp;length,<span class="type">int</span> p,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;length<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  e = sqList[p];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = p; i&lt;length<span class="number">-1</span>; ++i)</span><br><span class="line">    sqList[i] = sqList[i+<span class="number">1</span>];</span><br><span class="line">  --length;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>通常链表的插入和删除需要找到插入和删除操作的前驱结点，其实换位思考也可以进行后插或者删除后继结点，主要区别在于交换结点的数值。不再列举插入和删除的举例代码，只强调结点的删除需要使用<strong>free()函数</strong>。</p><h3 id="算法例题-1"><a href="#算法例题-1" class="headerlink" title="算法例题"></a>算法例题</h3><ol><li>设计一个算法，从一给定的顺序表L中删除下标i~j（$i \leq j$ ，包括i、j）的所有元素，<strong>假定i、j都是合法的</strong>。</li></ol><p>主要函数解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span>&amp;length,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> k,delta;</span><br><span class="line">  delta = j-i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(k = j+<span class="number">1</span>;k&lt;length;++k)</span><br><span class="line">    arr[k-delta] = arr[k];</span><br><span class="line">  length-=delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>有一个<strong>递增非空单链表</strong>，设计一个算法删除值域重复的结点。例如，{1,1,2,3,3,3,4,4,7,7,7,9,9,9}经过删除后变成{1,2,3,4,7,9}。</li></ol><p>主要函数解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p=L-&gt;next,*q;</span><br><span class="line">  <span class="keyword">while</span> (p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==p-&gt;next-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//典型的单链表删除操作方法</span></span><br><span class="line">      q=p-&gt;next;</span><br><span class="line">      p-&gt;next=q-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点四：建表"><a href="#考点四：建表" class="headerlink" title="考点四：建表"></a>考点四：建表</h2><h3 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h3><p>建表算法代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[maxsize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createList</span> <span class="params">(<span class="type">int</span> A[],<span class="type">int</span> &amp;length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;length;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; maxSize)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)</span><br><span class="line">    cin&gt;&gt;A[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p><strong>尾插法</strong>建立单链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createLinkListR</span><span class="params">(LNode *&amp;head)</span></span>&#123;</span><br><span class="line">  head = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  head-&gt;next =  <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p = <span class="literal">NULL</span>,*r = head;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cin&gt;&gt;p-&gt;data;</span><br><span class="line">    p-&gt;next = r-&gt;next;</span><br><span class="line">    r-&gt;next = p;</span><br><span class="line">    r = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>头插法</strong>建立单链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ceateLinkListH</span><span class="params">(LNode *&amp;head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  head = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cin&gt;&gt;p-&gt;data;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法附设了一个指向表尾结点的指针。</p><h3 id="算法例题-2"><a href="#算法例题-2" class="headerlink" title="算法例题"></a>算法例题</h3><p>键盘输入n个英文字母，输入格式为n、c1、c2、… 、cn，其中n表示字母的个数。请编程以这些输入数据建立一个单链表，并要求将字母不重复地存入链表。</p><p>主要函数解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createLinkNoSameElem</span><span class="params">(LNode *&amp;head)</span></span>&#123;</span><br><span class="line">  head = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i <span class="number">0</span>;i n;++i)&#123;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;data == ch)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p = <span class="literal">NULL</span>)&#123;</span><br><span class="line">      p = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">      p-&gt;data = ch;</span><br><span class="line">      p-&gt;next = head-&gt;next;</span><br><span class="line">      head-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点五：归并"><a href="#考点五：归并" class="headerlink" title="考点五：归并"></a>考点五：归并</h2><p>默认规则：两个递增有序线性表归并为一个递增有序线性表。</p><h3 id="顺序表归并"><a href="#顺序表归并" class="headerlink" title="顺序表归并"></a>顺序表归并</h3><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergearray</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> m,<span class="type">int</span> b[],<span class="type">int</span> n,<span class="type">int</span> c[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; m &amp;&amp;j &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]&lt;b[j])</span><br><span class="line">      c[k++]=a[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      c[k++]=b[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt; m)</span><br><span class="line">    c[k++]=a[i++];</span><br><span class="line">  <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">    c[k++]=b[j++];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表归并"><a href="#链表归并" class="headerlink" title="链表归并"></a>链表归并</h3><p>默认链表含有头结点。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p = A-&gt;next;</span><br><span class="line">  LNode *q = B-&gt;next;</span><br><span class="line">  LNode *r;</span><br><span class="line">  C=A;</span><br><span class="line">  C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">free</span>(B);<span class="comment">//记得释放其中一个头结点</span></span><br><span class="line">  r = C;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;q-&gt;data)&#123;</span><br><span class="line">      r-&gt;next = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      r-&gt;next = q;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">      r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) r-&gt;next = p;</span><br><span class="line">  <span class="keyword">if</span>(q!=<span class="literal">NULL</span>) r-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向归并，即将两个递增有序线性表归并为一个递减有序线性表，链表归并的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeR</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p = A-&gt;next;</span><br><span class="line">  LNode *q = B-&gt;next;</span><br><span class="line">  LNode *s;</span><br><span class="line">  C=A;</span><br><span class="line">  C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">free</span>(B);<span class="comment">//记得释放其中一个头结点</span></span><br><span class="line">  s = C;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;q-&gt;data)&#123;</span><br><span class="line">      s = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      s-&gt;next = C-&gt;next;</span><br><span class="line">      C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      s = q;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">      s-&gt;next = C-&gt;next;</span><br><span class="line">      C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    s = p;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    s-&gt;next = C-&gt;next;</span><br><span class="line">    C-&gt;next = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    s = q;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">    s-&gt;next = C-&gt;next;</span><br><span class="line">    C-&gt;next = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在顺序表的归并操作中，我们需要另外开辟存储空间，而在链表的归并中，我们只需新建一个头指针并更改指针的指向即可。</p><h2 id="考点六：逆置"><a href="#考点六：逆置" class="headerlink" title="考点六：逆置"></a>考点六：逆置</h2><h3 id="顺序表逆置"><a href="#顺序表逆置" class="headerlink" title="顺序表逆置"></a>顺序表逆置</h3><p>顺序表逆置过程需要辅助交换变量。示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = left, j = right; i &lt; j; ++i,--j)</span><br><span class="line">&#123;</span><br><span class="line">  temp = a[i];</span><br><span class="line">  a[i] = a[j];</span><br><span class="line">  a[j]= temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><p>链表逆置的基本思路就是，依次取下前面的结点往后插入，即涉及到单链表的基本的插入和删除操作。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆置p-&gt;next到q的结点</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next!=q)</span><br><span class="line">&#123;</span><br><span class="line">  t = p-&gt;next;</span><br><span class="line">  p-&gt;next = t-&gt;next;</span><br><span class="line">  t-&gt;next = q-&gt;next;</span><br><span class="line">  q-&gt;next = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆置单链表L，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LNode *p = L-&gt;next,*q;</span><br><span class="line">  L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法例题-3"><a href="#算法例题-3" class="headerlink" title="算法例题"></a>算法例题</h3><ol><li>将一长度为n的数组的前端k(k&lt;n)个元素<strong>逆序</strong>后移动到数组后端，要求原数组中<strong>数据不丢失</strong>；</li></ol><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = left, j = right;i &lt; left+k &amp;&amp; i &lt; j; ++i,--j)&#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将一长度为n的数组的前端k(k&lt;n)个元素保持<strong>原序</strong>移动到数组后端，要求原数组中<strong>数据不丢失</strong>；</li></ol><p>这个题目可以不采用逆置的方法实现，给出的解决方案利用了第一问的函数。解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveToEnd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,k<span class="number">-1</span>,k);</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题解析"><a href="#真题解析" class="headerlink" title="真题解析"></a>真题解析</h3><p>设将n（n&gt;1）个整数存放到一维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&lt;p&lt;n)个位置，即将R中的元素$(X_0,X_1,…X_{n-1})$，经过移动后变为：$(X_p,X_{p+1},…X_{n-1},X_0,X_1,…X_{p-1})$。<br>要求：<br>(1)给出算法的基本设计思想。<br>(2)根据设计思想，采用C或C++或JAVA语言描述算法，关键之处给出注释。<br>(3)说明你所设计算法的时间复杂度和空间复杂度。</p><blockquote><p>(1)设计思想：将前面p个元素作为一个整体逆置，然后将后面n-p个元素作为一个整体逆置。最后将整个数组逆置，实现序列循环左移p个元素的操作。</p></blockquote><blockquote><p>(2)解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveP</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,p<span class="number">-1</span>,p);</span><br><span class="line">  <span class="built_in">reverse</span>(a,p,n<span class="number">-1</span>,n-p);</span><br><span class="line">  <span class="built_in">reverse</span>(a,<span class="number">0</span>,n<span class="number">-1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>(3)时间复杂度O(n)，辅助空间相对于输入数据量而言是常数，空间复杂度为O(1)。</p></blockquote><p><strong>Notes：</strong></p><ul><li>一次循环运行时间是循环内语句的运行时间乘以循环次数；</li><li>嵌套循环运行时间为最内层语句执行次数乘以总循环次数；</li><li>并列的两个循环运行时间与执行次数数量级大的那个相同。</li></ul><h2 id="考点七：取最值"><a href="#考点七：取最值" class="headerlink" title="考点七：取最值"></a>考点七：取最值</h2><p>该知识点容易与其他知识点结合出题。下述代码在取得最值的同时取得了最值的索引，符合大部分取最值的要求。</p><h3 id="顺序表-2"><a href="#顺序表-2" class="headerlink" title="顺序表"></a>顺序表</h3><p>取最大值代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (max&lt;a[i])&#123;</span><br><span class="line">    max = a[i];</span><br><span class="line">    maxIdx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取最小值代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> min = a[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (min&gt;a[i])&#123;</span><br><span class="line">    min = a[i];</span><br><span class="line">    minIdx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-2"><a href="#链表-2" class="headerlink" title="链表"></a>链表</h3><p>由于取最大值和取最小值代码类似，仅示例取最大值代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LNode *p,*q;</span><br><span class="line"><span class="type">int</span> max = head-&gt;next-&gt;data;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line">q = p;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(max &lt; p-&gt;data)&#123;</span><br><span class="line">    max = p-&gt;data;</span><br><span class="line">    q = p;</span><br><span class="line">  &#125;</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法例题-4"><a href="#算法例题-4" class="headerlink" title="算法例题"></a>算法例题</h3><p>一<strong>双链表</strong>非空，由head指针指出，结点结构为{llink,data,rlink},请设计一个将结点数据域data值最大的那个结点（<strong>最大值结点只有一个</strong>）移动到链表最前边的算法，要求不得申请新结点空间。</p><p>思路：找出最大值结点；“删除”最大值结点；插入最大值结点。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxFirst</span><span class="params">(DLNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DLNode *p = head-&gt;rlink,*q = p;</span><br><span class="line">  <span class="type">int</span> max = p-&gt;data;</span><br><span class="line">  <span class="comment">//找最值：</span></span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(max &lt; p-&gt;data)&#123;</span><br><span class="line">      max = p-&gt;data;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;rlink;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//&quot;删除”：</span></span><br><span class="line">  DLNode *l = q-&gt;llink,*r = q-&gt;rlink;</span><br><span class="line">  l-&gt;rlink = r;</span><br><span class="line">  <span class="keyword">if</span> (r!=<span class="literal">NULL</span>)</span><br><span class="line">    r-&gt;llink=l;</span><br><span class="line">  <span class="comment">//插入：</span></span><br><span class="line">  q-&gt;llink = head;</span><br><span class="line">  q-&gt;rlink = head-&gt;rlink;</span><br><span class="line">  head-&gt;rlink = q;</span><br><span class="line">  q-&gt;rlink-&gt;llink = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有N个<strong>个位正整数</strong>存放在int型数组A[0, … , N-1]中，N为已定义的常量且N$\leq$9，数组A[]的长度为N，另给一个int型变量i，要求**只用上述变量(A[0]~A[N-1]与i，这N+1个整型变量)**写一个算法，找出这N个整数中的最小者，并且要求不能破坏数组A[]中的数据。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i=A[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">whi1e</span>(i/<span class="number">10</span>&lt;=N<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">10</span>&gt;A[i/<span class="number">10</span>])&#123;</span><br><span class="line">      i = i-i%<span class="number">10</span>;</span><br><span class="line">      i = i+A[i/<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    i=i+<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  i=i%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题解析-1"><a href="#真题解析-1" class="headerlink" title="真题解析"></a>真题解析</h3><p>假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示。</p><img src="/img/数据结构/第二章_1.png" style="zoom:80%;" /><p>设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为{data,next}，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置（如图中字符i所在结点的位置p)。<br>要求：<br>1)给出算法的基本设计思想。<br>2)根据设计思想，采用C或C++或JAVA语音描述算法，关键之处给出注释。<br>3)说明你所设计算法的时间复杂度。</p><blockquote><p>1)分别求出str1和str2所指的两个链表的长度m和n。令指针p、q分别指向str1和str2的头结点，若m&gt;&#x3D;n，则使p指向链表中的第m-n+1个结点；若m&lt;n，则使q指向链表中的第n-m+1个结点；即使指针p和q所指的结点到表尾的长度相等。将指针p和q同步向后移动，并判断它们是否指向同一结点。若p和q指向同一结点，则该点即为所求的共同后缀的起始位置。</p></blockquote><blockquote><p>2)解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">findFristCommon</span><span class="params">(LNode *str1,LNode *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">  LNode *p = str1-&gt;next,*q = str2-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    len1++;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    len2++;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (p=str1-&gt;next;len1&gt;len2;len1--)</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  <span class="keyword">for</span>(q=str2-&gt;next;len1&lt;len2;len2--)</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;p!=q)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    q=q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>3)时间复杂度为O(n)。</p></blockquote><h2 id="考点八：划分"><a href="#考点八：划分" class="headerlink" title="考点八：划分"></a>考点八：划分</h2><p>划分规则：以某个元素为标准，将线性表划分为左右两部分。这个标准一般称为枢轴，往年题型可以分为以下三种：以第一个元素为枢轴将顺序表划分； 设定比较标准将顺序表划分为左右两部分；以数组元素中任何一个元素作为枢轴进行划分。</p><h3 id="以第一个元素为枢轴将顺序表划分"><a href="#以第一个元素为枢轴将顺序表划分" class="headerlink" title="以第一个元素为枢轴将顺序表划分"></a>以第一个元素为枢轴将顺序表划分</h3><p>第一个元素为枢轴，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span> <span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>;</span><br><span class="line">  temp = arr[i];</span><br><span class="line">  <span class="comment">//始终判断i是否小于j</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= temp) --j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      ++i:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; temp) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设定比较标准将顺序表划分为左右两部分"><a href="#设定比较标准将顺序表划分为左右两部分" class="headerlink" title="设定比较标准将顺序表划分为左右两部分"></a>设定比较标准将顺序表划分为左右两部分</h3><p>第一个元素为枢轴，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span> <span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n,<span class="type">int</span> comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>;</span><br><span class="line">  temp = arr[i];</span><br><span class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= comp) --j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      ++i:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; comp) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当设置temp：X；comp：Y时：</p><ul><li>效果是把数组元素以Y为界限分成了前后两部分，前半部分小于Y，后半部分大于等于Y;</li><li>i和j最终指向的值是X，而不是Y。</li></ul><h3 id="以数组元素中任何一个元素作为枢轴进行划分"><a href="#以数组元素中任何一个元素作为枢轴进行划分" class="headerlink" title="以数组元素中任何一个元素作为枢轴进行划分"></a>以数组元素中任何一个元素作为枢轴进行划分</h3><p>以k位置上的元素作为枢轴，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span> <span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>;</span><br><span class="line">  temp = arr[<span class="number">0</span>];</span><br><span class="line">  arr[<span class="number">0</span>] = arr[k];</span><br><span class="line">  arr[k] = temp;</span><br><span class="line">  temp = arr[i];</span><br><span class="line">  <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= temp) --j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      ++i:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; temp) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">      arr[j] = arr[i];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>2023王道考研数据结构书籍</p><p><a href="https://www.bilibili.com/video/BV1C84y1q7LA?p=1&vd_source=fc6821318d7aa4e7bbf228b7bf4bd30f">2024天勤考研数据结构基础课</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习总结 | 第一期 | 绪论</title>
      <link href="/posts/ceb59870.html"/>
      <url>/posts/ceb59870.html</url>
      
        <content type="html"><![CDATA[<h2 id="复习重点"><a href="#复习重点" class="headerlink" title="复习重点"></a>复习重点</h2><p>该章复习主要掌握<strong>算法概念</strong>、深入理解<strong>逻辑结构和存储结构的关系</strong>、认清<strong>什么是数据结构</strong>和学会<strong>对算法分析其时间和空间复杂度</strong>。其中对算法的分析尤为重要，是历年考试的重点。</p><h2 id="逻辑结构和存储结构"><a href="#逻辑结构和存储结构" class="headerlink" title="逻辑结构和存储结构"></a>逻辑结构和存储结构</h2><p><strong>Notes：</strong></p><ul><li>逻辑结构是指数据元素之间的逻辑关系，独立于计算机，与数据的存储无关。</li><li>笼统地讲，逻辑结构有四种：“没关系”，“一对一”，“一对多”，“多对多”。简单地讲对应于集合，线性结构，树形结构，图状结构和网状结构。</li><li>存储结构，也称为物理结构，它包括数据元素及其关系的表示，指数据结构在计算机中的表示或映像（或计算机语言实现逻辑结构）。</li><li>存储结构主要包括：顺序存储、链式存储、索引存储和散列存储。重点在顺序和链式存储。顺序结构支持随机存取（Random Access），而链式结构只能实现顺序存取。链式结构重点代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line">LNode *L;</span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">A-&gt;next = B;</span><br><span class="line">B-&gt;next = C;</span><br></pre></td></tr></table></figure><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p><strong>Notes:</strong></p><ul><li>数据结构包括三方面：逻辑结构、存储结构和数据的运算（基本操作集）。运算的定义是针对逻辑结构的，指明其功能；运算的实现是针对存储结构的，指出具体步骤。</li><li>算法（Algorithm）是对特定问题求解步骤的一种描述，≠程序，且必须具备有穷性、确定性和可行性（其他特性：输入和输出）。</li><li>算法的时间复杂度不仅依赖于问题的规模<em>n</em>，也取决于待输入数据的性质（如输入数据元素的初始状态）。</li><li>算法的设计取决于所选定的逻辑结构，算法的实现依赖于所采用的存储结构。</li></ul><h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><p><strong>Notes：</strong></p><ul><li><p>时间和空间复杂度是对算法效率的度量。算法中所有语句的频度之和记为T(n)，时间复杂度就是分析其数量级。通常采用算法中的基本运算的频度f(n)来分析算法的时间复杂度：T(n)&#x3D;O(f(n))。</p></li><li><p>时间复杂度的一些规则和公式：</p><p>a) 加法规则：$$T(n)&#x3D;T_1(n)+T_2(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max(f(n),g(n)))$$</p><p>b) 乘法规则：$$T(n)&#x3D;T_1(n)×T_2(n)&#x3D;O(f(n))×O(g(n))&#x3D;O(f(n)×g(n))$$</p><p>c) 特定情况下简化计算的公式：</p><img src="/img/tupian.png" width="60%" height="60%" /><p>d) 常见的渐近时间复杂度：$$ \small O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) $$</p></li><li><p>空间复杂度S(n)定义为该算法所耗费的存储空间，是问题规模n的函数。</p></li><li><p>算法原地工作是指算法所需的辅助空间为常量，即O(1)。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>除夕夜前，自己的第一个博客出炉</title>
      <link href="/posts/ee9e06b0.html"/>
      <url>/posts/ee9e06b0.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​作为一名计算机专业的学生，总觉得自己应该有一个blog，同时还在网上看到了许多精美的个人blog，因此这个博客就诞生了（庆祝！！！）。这个博客的搭建是利用hexo框架+github搭建起来的，基本没有用到什么前端的知识（前端小白就可以搭建），有搭建想法的朋友可以参考<a href="https://anzhiy.cn/posts/ddae.html">保姆级教程</a>。</p><p>我之后会尽量持续更新和维护博客，或许不久后会加入评论系统，欢迎有兴趣的朋友持续关注哇。要是github托管下网速过于不稳定，之后可能会考虑利用服务器。</p><h2 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h2><p>​最后祝大家除夕夜快乐！！！</p><p>送给大家一个除夕<a href="../firework.html">烟火秀</a>。如果没有声音或过于卡顿，可以点<a href="https://cantelope.org/NYE/">此</a>欣赏。烟火秀的代码是在github开源代码上做了部分修改，有兴趣的朋友可以点击<a href="https://github.com/SakuraLQY/FireWorks">源码</a>链接自行查看github上的开源代码。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {  left: -66px !important;  transition: all 0.3s;  /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {  left: 0 !important;  transition: all 0.3s;  /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {  z-index: 999999 !important;}]]></content>
      
    </entry>
    
    
  
</search>
